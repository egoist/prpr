{"version":3,"sources":["webpack:///prpr.min.js","webpack:///webpack/bootstrap fb3bf75b2e0abbaea371","webpack:///C:/Users/EGOIST/dev/prpr/~/babel-runtime/helpers/class-call-check.js","webpack:///C:/Users/EGOIST/dev/prpr/src/index.js","webpack:///C:/Users/EGOIST/dev/prpr/~/dom-delegate/lib/delegate.js","webpack:///C:/Users/EGOIST/dev/prpr/~/dom-delegate/lib/index.js"],"names":["PrPr","modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","instance","Constructor","TypeError","__esModule","_classCallCheck","Object","defineProperty","value","_domDelegate","document","querySelector","bind","querySelectorAll","opts","this","delegate","Delegate","body","on","e","preventDefault","console","log","getAttribute","root","listenerMap","handle","prototype","matchesTag","tagName","element","toLowerCase","matchesRoot","selector","rootElement","window","matchesId","eventType","hasOwnProperty","removeEventListener","addEventListener","captureForType","indexOf","handler","useCapture","matcher","matcherParam","undefined","test","slice","matches","push","off","i","listener","listenerList","singleEventType","length","splice","event","l","phase","returned","target","type","EVENTIGNORE","nodeType","parentNode","eventPhase","currentTarget","concat","fire","parentElement","el","matchesSelector","webkitMatchesSelector","mozMatchesSelector","msMatchesSelector","oMatchesSelector","Element","destroy"],"mappings":"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","file":"prpr.min.js","sourcesContent":["var PrPr =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(2);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\texports[\"default\"] = function (instance, Constructor) {\n\t  if (!(instance instanceof Constructor)) {\n\t    throw new TypeError(\"Cannot call a class as a function\");\n\t  }\n\t};\n\t\n\texports.__esModule = true;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _classCallCheck = __webpack_require__(1)['default'];\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\t\n\tvar _domDelegate = __webpack_require__(4);\n\t\n\tvar $ = document.querySelector.bind(document);\n\tvar $$ = document.querySelectorAll.bind(document);\n\t\n\tvar PrPr = function PrPr(opts) {\n\t  _classCallCheck(this, PrPr);\n\t\n\t  this.opts = opts;\n\t  var delegate = new _domDelegate.Delegate(document.body);\n\t  delegate.on('click', 'a', function (e) {\n\t    e.preventDefault();\n\t    console.log(this.getAttribute('href'));\n\t  });\n\t};\n\t\n\texports['default'] = PrPr;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t/*jshint browser:true, node:true*/\n\t\n\t/*HACK:MA:20140428 Event currently not a browser global in JSHint - https://github.com/jshint/jshint/pull/1645 */\n\t/*global Event*/\n\t\n\t'use strict';\n\t\n\tmodule.exports = Delegate;\n\t\n\t/**\n\t * DOM event delegator\n\t *\n\t * The delegator will listen\n\t * for events that bubble up\n\t * to the root node.\n\t *\n\t * @constructor\n\t * @param {Node|string} [root] The root node or a selector string matching the root node\n\t */\n\tfunction Delegate(root) {\n\t\n\t  /**\n\t   * Maintain a map of listener\n\t   * lists, keyed by event name.\n\t   *\n\t   * @type Object\n\t   */\n\t  this.listenerMap = [{}, {}];\n\t  if (root) {\n\t    this.root(root);\n\t  }\n\t\n\t  /** @type function() */\n\t  this.handle = Delegate.prototype.handle.bind(this);\n\t}\n\t\n\t/**\n\t * Start listening for events\n\t * on the provided DOM element\n\t *\n\t * @param  {Node|string} [root] The root node or a selector string matching the root node\n\t * @returns {Delegate} This method is chainable\n\t */\n\tDelegate.prototype.root = function (root) {\n\t  var listenerMap = this.listenerMap;\n\t  var eventType;\n\t\n\t  if (typeof root === 'string') {\n\t    root = document.querySelector(root);\n\t  }\n\t\n\t  // Remove master event listeners\n\t  if (this.rootElement) {\n\t    for (eventType in listenerMap[1]) {\n\t      if (listenerMap[1].hasOwnProperty(eventType)) {\n\t        this.rootElement.removeEventListener(eventType, this.handle, true);\n\t      }\n\t    }\n\t    for (eventType in listenerMap[0]) {\n\t      if (listenerMap[0].hasOwnProperty(eventType)) {\n\t        this.rootElement.removeEventListener(eventType, this.handle, false);\n\t      }\n\t    }\n\t  }\n\t\n\t  // If no root or root is not\n\t  // a dom node, then remove internal\n\t  // root reference and exit here\n\t  if (!root || !root.addEventListener) {\n\t    if (this.rootElement) {\n\t      delete this.rootElement;\n\t    }\n\t    return this;\n\t  }\n\t\n\t  /**\n\t   * The root node at which\n\t   * listeners are attached.\n\t   *\n\t   * @type Node\n\t   */\n\t  this.rootElement = root;\n\t\n\t  // Set up master event listeners\n\t  for (eventType in listenerMap[1]) {\n\t    if (listenerMap[1].hasOwnProperty(eventType)) {\n\t      this.rootElement.addEventListener(eventType, this.handle, true);\n\t    }\n\t  }\n\t  for (eventType in listenerMap[0]) {\n\t    if (listenerMap[0].hasOwnProperty(eventType)) {\n\t      this.rootElement.addEventListener(eventType, this.handle, false);\n\t    }\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * @param {string} eventType\n\t * @returns boolean\n\t */\n\tDelegate.prototype.captureForType = function (eventType) {\n\t  return ['blur', 'error', 'focus', 'load', 'resize', 'scroll'].indexOf(eventType) !== -1;\n\t};\n\t\n\t/**\n\t * Attach a handler to one\n\t * event for all elements\n\t * that match the selector,\n\t * now or in the future\n\t *\n\t * The handler function receives\n\t * three arguments: the DOM event\n\t * object, the node that matched\n\t * the selector while the event\n\t * was bubbling and a reference\n\t * to itself. Within the handler,\n\t * 'this' is equal to the second\n\t * argument.\n\t *\n\t * The node that actually received\n\t * the event can be accessed via\n\t * 'event.target'.\n\t *\n\t * @param {string} eventType Listen for these events\n\t * @param {string|undefined} selector Only handle events on elements matching this selector, if undefined match root element\n\t * @param {function()} handler Handler function - event data passed here will be in event.data\n\t * @param {Object} [eventData] Data to pass in event.data\n\t * @returns {Delegate} This method is chainable\n\t */\n\tDelegate.prototype.on = function (eventType, selector, handler, useCapture) {\n\t  var root, listenerMap, matcher, matcherParam;\n\t\n\t  if (!eventType) {\n\t    throw new TypeError('Invalid event type: ' + eventType);\n\t  }\n\t\n\t  // handler can be passed as\n\t  // the second or third argument\n\t  if (typeof selector === 'function') {\n\t    useCapture = handler;\n\t    handler = selector;\n\t    selector = null;\n\t  }\n\t\n\t  // Fallback to sensible defaults\n\t  // if useCapture not set\n\t  if (useCapture === undefined) {\n\t    useCapture = this.captureForType(eventType);\n\t  }\n\t\n\t  if (typeof handler !== 'function') {\n\t    throw new TypeError('Handler must be a type of Function');\n\t  }\n\t\n\t  root = this.rootElement;\n\t  listenerMap = this.listenerMap[useCapture ? 1 : 0];\n\t\n\t  // Add master handler for type if not created yet\n\t  if (!listenerMap[eventType]) {\n\t    if (root) {\n\t      root.addEventListener(eventType, this.handle, useCapture);\n\t    }\n\t    listenerMap[eventType] = [];\n\t  }\n\t\n\t  if (!selector) {\n\t    matcherParam = null;\n\t\n\t    // COMPLEX - matchesRoot needs to have access to\n\t    // this.rootElement, so bind the function to this.\n\t    matcher = matchesRoot.bind(this);\n\t\n\t    // Compile a matcher for the given selector\n\t  } else if (/^[a-z]+$/i.test(selector)) {\n\t      matcherParam = selector;\n\t      matcher = matchesTag;\n\t    } else if (/^#[a-z0-9\\-_]+$/i.test(selector)) {\n\t      matcherParam = selector.slice(1);\n\t      matcher = matchesId;\n\t    } else {\n\t      matcherParam = selector;\n\t      matcher = matches;\n\t    }\n\t\n\t  // Add to the list of listeners\n\t  listenerMap[eventType].push({\n\t    selector: selector,\n\t    handler: handler,\n\t    matcher: matcher,\n\t    matcherParam: matcherParam\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Remove an event handler\n\t * for elements that match\n\t * the selector, forever\n\t *\n\t * @param {string} [eventType] Remove handlers for events matching this type, considering the other parameters\n\t * @param {string} [selector] If this parameter is omitted, only handlers which match the other two will be removed\n\t * @param {function()} [handler] If this parameter is omitted, only handlers which match the previous two will be removed\n\t * @returns {Delegate} This method is chainable\n\t */\n\tDelegate.prototype.off = function (eventType, selector, handler, useCapture) {\n\t  var i, listener, listenerMap, listenerList, singleEventType;\n\t\n\t  // Handler can be passed as\n\t  // the second or third argument\n\t  if (typeof selector === 'function') {\n\t    useCapture = handler;\n\t    handler = selector;\n\t    selector = null;\n\t  }\n\t\n\t  // If useCapture not set, remove\n\t  // all event listeners\n\t  if (useCapture === undefined) {\n\t    this.off(eventType, selector, handler, true);\n\t    this.off(eventType, selector, handler, false);\n\t    return this;\n\t  }\n\t\n\t  listenerMap = this.listenerMap[useCapture ? 1 : 0];\n\t  if (!eventType) {\n\t    for (singleEventType in listenerMap) {\n\t      if (listenerMap.hasOwnProperty(singleEventType)) {\n\t        this.off(singleEventType, selector, handler);\n\t      }\n\t    }\n\t\n\t    return this;\n\t  }\n\t\n\t  listenerList = listenerMap[eventType];\n\t  if (!listenerList || !listenerList.length) {\n\t    return this;\n\t  }\n\t\n\t  // Remove only parameter matches\n\t  // if specified\n\t  for (i = listenerList.length - 1; i >= 0; i--) {\n\t    listener = listenerList[i];\n\t\n\t    if ((!selector || selector === listener.selector) && (!handler || handler === listener.handler)) {\n\t      listenerList.splice(i, 1);\n\t    }\n\t  }\n\t\n\t  // All listeners removed\n\t  if (!listenerList.length) {\n\t    delete listenerMap[eventType];\n\t\n\t    // Remove the main handler\n\t    if (this.rootElement) {\n\t      this.rootElement.removeEventListener(eventType, this.handle, useCapture);\n\t    }\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Handle an arbitrary event.\n\t *\n\t * @param {Event} event\n\t */\n\tDelegate.prototype.handle = function (event) {\n\t  var i,\n\t      l,\n\t      type = event.type,\n\t      root,\n\t      phase,\n\t      listener,\n\t      returned,\n\t      listenerList = [],\n\t      target,\n\t      /** @const */EVENTIGNORE = 'ftLabsDelegateIgnore';\n\t\n\t  if (event[EVENTIGNORE] === true) {\n\t    return;\n\t  }\n\t\n\t  target = event.target;\n\t\n\t  // Hardcode value of Node.TEXT_NODE\n\t  // as not defined in IE8\n\t  if (target.nodeType === 3) {\n\t    target = target.parentNode;\n\t  }\n\t\n\t  root = this.rootElement;\n\t\n\t  phase = event.eventPhase || (event.target !== event.currentTarget ? 3 : 2);\n\t\n\t  switch (phase) {\n\t    case 1:\n\t      //Event.CAPTURING_PHASE:\n\t      listenerList = this.listenerMap[1][type];\n\t      break;\n\t    case 2:\n\t      //Event.AT_TARGET:\n\t      if (this.listenerMap[0] && this.listenerMap[0][type]) listenerList = listenerList.concat(this.listenerMap[0][type]);\n\t      if (this.listenerMap[1] && this.listenerMap[1][type]) listenerList = listenerList.concat(this.listenerMap[1][type]);\n\t      break;\n\t    case 3:\n\t      //Event.BUBBLING_PHASE:\n\t      listenerList = this.listenerMap[0][type];\n\t      break;\n\t  }\n\t\n\t  // Need to continuously check\n\t  // that the specific list is\n\t  // still populated in case one\n\t  // of the callbacks actually\n\t  // causes the list to be destroyed.\n\t  l = listenerList.length;\n\t  while (target && l) {\n\t    for (i = 0; i < l; i++) {\n\t      listener = listenerList[i];\n\t\n\t      // Bail from this loop if\n\t      // the length changed and\n\t      // no more listeners are\n\t      // defined between i and l.\n\t      if (!listener) {\n\t        break;\n\t      }\n\t\n\t      // Check for match and fire\n\t      // the event if there's one\n\t      //\n\t      // TODO:MCG:20120117: Need a way\n\t      // to check if event#stopImmediatePropagation\n\t      // was called. If so, break both loops.\n\t      if (listener.matcher.call(target, listener.matcherParam, target)) {\n\t        returned = this.fire(event, target, listener);\n\t      }\n\t\n\t      // Stop propagation to subsequent\n\t      // callbacks if the callback returned\n\t      // false\n\t      if (returned === false) {\n\t        event[EVENTIGNORE] = true;\n\t        event.preventDefault();\n\t        return;\n\t      }\n\t    }\n\t\n\t    // TODO:MCG:20120117: Need a way to\n\t    // check if event#stopPropagation\n\t    // was called. If so, break looping\n\t    // through the DOM. Stop if the\n\t    // delegation root has been reached\n\t    if (target === root) {\n\t      break;\n\t    }\n\t\n\t    l = listenerList.length;\n\t    target = target.parentElement;\n\t  }\n\t};\n\t\n\t/**\n\t * Fire a listener on a target.\n\t *\n\t * @param {Event} event\n\t * @param {Node} target\n\t * @param {Object} listener\n\t * @returns {boolean}\n\t */\n\tDelegate.prototype.fire = function (event, target, listener) {\n\t  return listener.handler.call(target, event, target);\n\t};\n\t\n\t/**\n\t * Check whether an element\n\t * matches a generic selector.\n\t *\n\t * @type function()\n\t * @param {string} selector A CSS selector\n\t */\n\tvar matches = (function (el) {\n\t  if (!el) return;\n\t  var p = el.prototype;\n\t  return p.matches || p.matchesSelector || p.webkitMatchesSelector || p.mozMatchesSelector || p.msMatchesSelector || p.oMatchesSelector;\n\t})(Element);\n\t\n\t/**\n\t * Check whether an element\n\t * matches a tag selector.\n\t *\n\t * Tags are NOT case-sensitive,\n\t * except in XML (and XML-based\n\t * languages such as XHTML).\n\t *\n\t * @param {string} tagName The tag name to test against\n\t * @param {Element} element The element to test with\n\t * @returns boolean\n\t */\n\tfunction matchesTag(tagName, element) {\n\t  return tagName.toLowerCase() === element.tagName.toLowerCase();\n\t}\n\t\n\t/**\n\t * Check whether an element\n\t * matches the root.\n\t *\n\t * @param {?String} selector In this case this is always passed through as null and not used\n\t * @param {Element} element The element to test with\n\t * @returns boolean\n\t */\n\tfunction matchesRoot(selector, element) {\n\t  /*jshint validthis:true*/\n\t  if (this.rootElement === window) return element === document;\n\t  return this.rootElement === element;\n\t}\n\t\n\t/**\n\t * Check whether the ID of\n\t * the element in 'this'\n\t * matches the given ID.\n\t *\n\t * IDs are case-sensitive.\n\t *\n\t * @param {string} id The ID to test against\n\t * @param {Element} element The element to test with\n\t * @returns boolean\n\t */\n\tfunction matchesId(id, element) {\n\t  return id === element.id;\n\t}\n\t\n\t/**\n\t * Short hand for off()\n\t * and root(), ie both\n\t * with no parameters\n\t *\n\t * @return void\n\t */\n\tDelegate.prototype.destroy = function () {\n\t  this.off();\n\t  this.root();\n\t};\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*jshint browser:true, node:true*/\n\t\n\t'use strict';\n\t\n\t/**\n\t * @preserve Create and manage a DOM event delegator.\n\t *\n\t * @version 0.3.0\n\t * @codingstandard ftlabs-jsv2\n\t * @copyright The Financial Times Limited [All Rights Reserved]\n\t * @license MIT License (see LICENSE.txt)\n\t */\n\tvar Delegate = __webpack_require__(3);\n\t\n\tmodule.exports = function (root) {\n\t  return new Delegate(root);\n\t};\n\t\n\tmodule.exports.Delegate = Delegate;\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** prpr.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap fb3bf75b2e0abbaea371\n **/","\"use strict\";\n\nexports[\"default\"] = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nexports.__esModule = true;\n\n\n/** WEBPACK FOOTER **\n ** C:/Users/EGOIST/dev/prpr/~/babel-runtime/helpers/class-call-check.js\n **/","import { Delegate } from 'dom-delegate'\r\n\r\nconst $ = document.querySelector.bind(document)\r\nconst $$ = document.querySelectorAll.bind(document)\r\n\r\nexport default class PrPr {\r\n  constructor(opts) {\r\n    this.opts = opts\r\n    const delegate = new Delegate(document.body)\r\n    delegate.on('click', 'a', function (e) {\r\n      e.preventDefault()\r\n      console.log(this.getAttribute('href'))\r\n    })\r\n  }\r\n\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** C:/Users/EGOIST/dev/prpr/src/index.js\n **/","/*jshint browser:true, node:true*/\n\n/*HACK:MA:20140428 Event currently not a browser global in JSHint - https://github.com/jshint/jshint/pull/1645 */\n/*global Event*/\n\n'use strict';\n\nmodule.exports = Delegate;\n\n/**\n * DOM event delegator\n *\n * The delegator will listen\n * for events that bubble up\n * to the root node.\n *\n * @constructor\n * @param {Node|string} [root] The root node or a selector string matching the root node\n */\nfunction Delegate(root) {\n\n  /**\n   * Maintain a map of listener\n   * lists, keyed by event name.\n   *\n   * @type Object\n   */\n  this.listenerMap = [{}, {}];\n  if (root) {\n    this.root(root);\n  }\n\n  /** @type function() */\n  this.handle = Delegate.prototype.handle.bind(this);\n}\n\n/**\n * Start listening for events\n * on the provided DOM element\n *\n * @param  {Node|string} [root] The root node or a selector string matching the root node\n * @returns {Delegate} This method is chainable\n */\nDelegate.prototype.root = function(root) {\n  var listenerMap = this.listenerMap;\n  var eventType;\n\n  if (typeof root === 'string') {\n    root = document.querySelector(root);\n  }\n\n  // Remove master event listeners\n  if (this.rootElement) {\n    for (eventType in listenerMap[1]) {\n      if (listenerMap[1].hasOwnProperty(eventType)) {\n        this.rootElement.removeEventListener(eventType, this.handle, true);\n      }\n    }\n    for (eventType in listenerMap[0]) {\n      if (listenerMap[0].hasOwnProperty(eventType)) {\n        this.rootElement.removeEventListener(eventType, this.handle, false);\n      }\n    }\n  }\n\n  // If no root or root is not\n  // a dom node, then remove internal\n  // root reference and exit here\n  if (!root || !root.addEventListener) {\n    if (this.rootElement) {\n      delete this.rootElement;\n    }\n    return this;\n  }\n\n  /**\n   * The root node at which\n   * listeners are attached.\n   *\n   * @type Node\n   */\n  this.rootElement = root;\n\n  // Set up master event listeners\n  for (eventType in listenerMap[1]) {\n    if (listenerMap[1].hasOwnProperty(eventType)) {\n      this.rootElement.addEventListener(eventType, this.handle, true);\n    }\n  }\n  for (eventType in listenerMap[0]) {\n    if (listenerMap[0].hasOwnProperty(eventType)) {\n      this.rootElement.addEventListener(eventType, this.handle, false);\n    }\n  }\n\n  return this;\n};\n\n/**\n * @param {string} eventType\n * @returns boolean\n */\nDelegate.prototype.captureForType = function(eventType) {\n  return ['blur', 'error', 'focus', 'load', 'resize', 'scroll'].indexOf(eventType) !== -1;\n};\n\n/**\n * Attach a handler to one\n * event for all elements\n * that match the selector,\n * now or in the future\n *\n * The handler function receives\n * three arguments: the DOM event\n * object, the node that matched\n * the selector while the event\n * was bubbling and a reference\n * to itself. Within the handler,\n * 'this' is equal to the second\n * argument.\n *\n * The node that actually received\n * the event can be accessed via\n * 'event.target'.\n *\n * @param {string} eventType Listen for these events\n * @param {string|undefined} selector Only handle events on elements matching this selector, if undefined match root element\n * @param {function()} handler Handler function - event data passed here will be in event.data\n * @param {Object} [eventData] Data to pass in event.data\n * @returns {Delegate} This method is chainable\n */\nDelegate.prototype.on = function(eventType, selector, handler, useCapture) {\n  var root, listenerMap, matcher, matcherParam;\n\n  if (!eventType) {\n    throw new TypeError('Invalid event type: ' + eventType);\n  }\n\n  // handler can be passed as\n  // the second or third argument\n  if (typeof selector === 'function') {\n    useCapture = handler;\n    handler = selector;\n    selector = null;\n  }\n\n  // Fallback to sensible defaults\n  // if useCapture not set\n  if (useCapture === undefined) {\n    useCapture = this.captureForType(eventType);\n  }\n\n  if (typeof handler !== 'function') {\n    throw new TypeError('Handler must be a type of Function');\n  }\n\n  root = this.rootElement;\n  listenerMap = this.listenerMap[useCapture ? 1 : 0];\n\n  // Add master handler for type if not created yet\n  if (!listenerMap[eventType]) {\n    if (root) {\n      root.addEventListener(eventType, this.handle, useCapture);\n    }\n    listenerMap[eventType] = [];\n  }\n\n  if (!selector) {\n    matcherParam = null;\n\n    // COMPLEX - matchesRoot needs to have access to\n    // this.rootElement, so bind the function to this.\n    matcher = matchesRoot.bind(this);\n\n  // Compile a matcher for the given selector\n  } else if (/^[a-z]+$/i.test(selector)) {\n    matcherParam = selector;\n    matcher = matchesTag;\n  } else if (/^#[a-z0-9\\-_]+$/i.test(selector)) {\n    matcherParam = selector.slice(1);\n    matcher = matchesId;\n  } else {\n    matcherParam = selector;\n    matcher = matches;\n  }\n\n  // Add to the list of listeners\n  listenerMap[eventType].push({\n    selector: selector,\n    handler: handler,\n    matcher: matcher,\n    matcherParam: matcherParam\n  });\n\n  return this;\n};\n\n/**\n * Remove an event handler\n * for elements that match\n * the selector, forever\n *\n * @param {string} [eventType] Remove handlers for events matching this type, considering the other parameters\n * @param {string} [selector] If this parameter is omitted, only handlers which match the other two will be removed\n * @param {function()} [handler] If this parameter is omitted, only handlers which match the previous two will be removed\n * @returns {Delegate} This method is chainable\n */\nDelegate.prototype.off = function(eventType, selector, handler, useCapture) {\n  var i, listener, listenerMap, listenerList, singleEventType;\n\n  // Handler can be passed as\n  // the second or third argument\n  if (typeof selector === 'function') {\n    useCapture = handler;\n    handler = selector;\n    selector = null;\n  }\n\n  // If useCapture not set, remove\n  // all event listeners\n  if (useCapture === undefined) {\n    this.off(eventType, selector, handler, true);\n    this.off(eventType, selector, handler, false);\n    return this;\n  }\n\n  listenerMap = this.listenerMap[useCapture ? 1 : 0];\n  if (!eventType) {\n    for (singleEventType in listenerMap) {\n      if (listenerMap.hasOwnProperty(singleEventType)) {\n        this.off(singleEventType, selector, handler);\n      }\n    }\n\n    return this;\n  }\n\n  listenerList = listenerMap[eventType];\n  if (!listenerList || !listenerList.length) {\n    return this;\n  }\n\n  // Remove only parameter matches\n  // if specified\n  for (i = listenerList.length - 1; i >= 0; i--) {\n    listener = listenerList[i];\n\n    if ((!selector || selector === listener.selector) && (!handler || handler === listener.handler)) {\n      listenerList.splice(i, 1);\n    }\n  }\n\n  // All listeners removed\n  if (!listenerList.length) {\n    delete listenerMap[eventType];\n\n    // Remove the main handler\n    if (this.rootElement) {\n      this.rootElement.removeEventListener(eventType, this.handle, useCapture);\n    }\n  }\n\n  return this;\n};\n\n\n/**\n * Handle an arbitrary event.\n *\n * @param {Event} event\n */\nDelegate.prototype.handle = function(event) {\n  var i, l, type = event.type, root, phase, listener, returned, listenerList = [], target, /** @const */ EVENTIGNORE = 'ftLabsDelegateIgnore';\n\n  if (event[EVENTIGNORE] === true) {\n    return;\n  }\n\n  target = event.target;\n\n  // Hardcode value of Node.TEXT_NODE\n  // as not defined in IE8\n  if (target.nodeType === 3) {\n    target = target.parentNode;\n  }\n\n  root = this.rootElement;\n\n  phase = event.eventPhase || ( event.target !== event.currentTarget ? 3 : 2 );\n  \n  switch (phase) {\n    case 1: //Event.CAPTURING_PHASE:\n      listenerList = this.listenerMap[1][type];\n    break;\n    case 2: //Event.AT_TARGET:\n      if (this.listenerMap[0] && this.listenerMap[0][type]) listenerList = listenerList.concat(this.listenerMap[0][type]);\n      if (this.listenerMap[1] && this.listenerMap[1][type]) listenerList = listenerList.concat(this.listenerMap[1][type]);\n    break;\n    case 3: //Event.BUBBLING_PHASE:\n      listenerList = this.listenerMap[0][type];\n    break;\n  }\n\n  // Need to continuously check\n  // that the specific list is\n  // still populated in case one\n  // of the callbacks actually\n  // causes the list to be destroyed.\n  l = listenerList.length;\n  while (target && l) {\n    for (i = 0; i < l; i++) {\n      listener = listenerList[i];\n\n      // Bail from this loop if\n      // the length changed and\n      // no more listeners are\n      // defined between i and l.\n      if (!listener) {\n        break;\n      }\n\n      // Check for match and fire\n      // the event if there's one\n      //\n      // TODO:MCG:20120117: Need a way\n      // to check if event#stopImmediatePropagation\n      // was called. If so, break both loops.\n      if (listener.matcher.call(target, listener.matcherParam, target)) {\n        returned = this.fire(event, target, listener);\n      }\n\n      // Stop propagation to subsequent\n      // callbacks if the callback returned\n      // false\n      if (returned === false) {\n        event[EVENTIGNORE] = true;\n        event.preventDefault();\n        return;\n      }\n    }\n\n    // TODO:MCG:20120117: Need a way to\n    // check if event#stopPropagation\n    // was called. If so, break looping\n    // through the DOM. Stop if the\n    // delegation root has been reached\n    if (target === root) {\n      break;\n    }\n\n    l = listenerList.length;\n    target = target.parentElement;\n  }\n};\n\n/**\n * Fire a listener on a target.\n *\n * @param {Event} event\n * @param {Node} target\n * @param {Object} listener\n * @returns {boolean}\n */\nDelegate.prototype.fire = function(event, target, listener) {\n  return listener.handler.call(target, event, target);\n};\n\n/**\n * Check whether an element\n * matches a generic selector.\n *\n * @type function()\n * @param {string} selector A CSS selector\n */\nvar matches = (function(el) {\n  if (!el) return;\n  var p = el.prototype;\n  return (p.matches || p.matchesSelector || p.webkitMatchesSelector || p.mozMatchesSelector || p.msMatchesSelector || p.oMatchesSelector);\n}(Element));\n\n/**\n * Check whether an element\n * matches a tag selector.\n *\n * Tags are NOT case-sensitive,\n * except in XML (and XML-based\n * languages such as XHTML).\n *\n * @param {string} tagName The tag name to test against\n * @param {Element} element The element to test with\n * @returns boolean\n */\nfunction matchesTag(tagName, element) {\n  return tagName.toLowerCase() === element.tagName.toLowerCase();\n}\n\n/**\n * Check whether an element\n * matches the root.\n *\n * @param {?String} selector In this case this is always passed through as null and not used\n * @param {Element} element The element to test with\n * @returns boolean\n */\nfunction matchesRoot(selector, element) {\n  /*jshint validthis:true*/\n  if (this.rootElement === window) return element === document;\n  return this.rootElement === element;\n}\n\n/**\n * Check whether the ID of\n * the element in 'this'\n * matches the given ID.\n *\n * IDs are case-sensitive.\n *\n * @param {string} id The ID to test against\n * @param {Element} element The element to test with\n * @returns boolean\n */\nfunction matchesId(id, element) {\n  return id === element.id;\n}\n\n/**\n * Short hand for off()\n * and root(), ie both\n * with no parameters\n *\n * @return void\n */\nDelegate.prototype.destroy = function() {\n  this.off();\n  this.root();\n};\n\n\n\n/** WEBPACK FOOTER **\n ** C:/Users/EGOIST/dev/prpr/~/dom-delegate/lib/delegate.js\n **/","/*jshint browser:true, node:true*/\n\n'use strict';\n\n/**\n * @preserve Create and manage a DOM event delegator.\n *\n * @version 0.3.0\n * @codingstandard ftlabs-jsv2\n * @copyright The Financial Times Limited [All Rights Reserved]\n * @license MIT License (see LICENSE.txt)\n */\nvar Delegate = require('./delegate');\n\nmodule.exports = function(root) {\n  return new Delegate(root);\n};\n\nmodule.exports.Delegate = Delegate;\n\n\n\n/** WEBPACK FOOTER **\n ** C:/Users/EGOIST/dev/prpr/~/dom-delegate/lib/index.js\n **/"],"sourceRoot":""}